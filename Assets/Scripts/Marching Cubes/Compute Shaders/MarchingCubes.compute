#include "UnityCG.cginc"
#include "Include/Tables.compute"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel DistributeDensity
#pragma kernel GenerateMesh
#pragma kernel Terraform

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
static const int threads = 8;
static const uint vegetationSparsity = 8;
static const float vegetationDensity = 0.4;

static const float LOW_FEATURE_LEVEL = .48;
static const float HIGH_FEATURE_LEVEL = .52;

static const uint featureCount = 4;
static const uint biomeCount = 16; // 2^featureCount
 
struct Triangle {
	float3 a;
	float3 b;
	float3 c;
	float3 padding; // padding to align to 16 bytes
};

struct BiomeNode {
  float t; // interpolation value for siblings
};

struct BiomeTree {
  BiomeNode nodes[16];
};

struct BiomeInterpolation {
  float values[16];
};

RWStructuredBuffer<float> _ChunkVertices;
AppendStructuredBuffer<Triangle> _ChunkTriangles;
AppendStructuredBuffer<float4> _ChunkVegetation;
Texture2D<float4> _NoiseMapVol1;
Texture2D<float4> _NoiseMapVol2;
Texture2D<float4> _NoiseMapVol3;

Texture2D<float4> _ErosionMap;
Texture2D<float4> _TemperatureMap;
Texture2D<float4> _PrecipitationMap;
Texture2D<float4> _SeismicMap;
 
SamplerState TrilinearRepeat;

float3 _ChunkPosition;
uint _ChunkSize;
float _IsoLevel;
float _Scale;
float _Elevation;
float3 _TerraformPosition;
float _TerraformRadius;
float _TerraformStrength;
int _TerraformDirection;

// ====================== Constructors ====================== //

Triangle CreateTriangle(float3 a, float3 b, float3 c) {
	Triangle tri;
	tri.a = a;
	tri.b = b;
	tri.c = c;
	tri.padding = float3(0, 0, 0);
	return tri;
}

BiomeNode CreateBiomeNode(float t){
  BiomeNode node;
  node.t = t;
  return node;
}

BiomeTree CreateBiomeTree(){
  BiomeTree tree;
  for (uint i = 0; i < biomeCount; i++){
    tree.nodes[i] = CreateBiomeNode(1.0);
  }
  return tree;
}

// ====================== Utils ====================== //

/**
 * Returns the position of the triangle's centroid.
*/
float3 GetCentroid(Triangle tri){
	return float3((tri.a + tri.b + tri.c) / 3);
}

/**
 * Returns the triangle's normal.
*/
float3 GetNormal(Triangle tri){
	float3 v1 = tri.b - tri.a;
	float3 v2 = tri.c - tri.a;
	
	return normalize(cross(v1, v2));
}

/**
 * Gets the index of vertex ate (x, y, z)
 * in _ChunkVertices
*/
uint PositionToBufferIndex(uint3 id){
	return id.x + (id.y * _ChunkSize) + (id.z * _ChunkSize * _ChunkSize);
}

/**
 * Get the position of the vertex with
 * index "vertexId" on the voxel
 * with origin at (0, 0, 0)
*/
uint3 GetVertexOffset(uint vertexId){
	if(vertexId < 8) return offsetForVertex[vertexId];
	else return uint3(0, 0, 0);
}

/**
 * Get the id of the vertices that
 * make up the edge "edgeId" on the voxel
*/
uint2 GetVerticesForEdge(uint edgeId){
	if(edgeId < 12) return verticesForEdge[edgeId];
	else return uint2(0, 0);
}

/**
 * Inverse linear interpolation
*/
float InverseLerp(float a, float b, float v){
	return clamp((v - a) / (b - a), 0, 1);
}

/**
 * Linear interpolation of vectors
*/
float3 LerpPosition(float3 a, float3 b, float t){
	return ((1 - t) * a) + (b * t);
}

// ====================== Biome Interpolation ====================== //



BiomeTree InterpolateBiomes(float features[4]){
  // create the root node
  BiomeTree tree = CreateBiomeTree();

  for (uint depth = 0; depth < featureCount; depth++){
    for(uint index = 0; index < biomeCount; index = index + biomeCount / pow(2, depth)){
      BiomeNode node = tree.nodes[index];
      float t = node.t;

      uint slice = biomeCount / pow(2, depth);
      uint leftIndex = index;
      uint rightIndex = index + (slice / 2); 

      float feature = features[depth];
      if (feature <= LOW_FEATURE_LEVEL){
        // create the left child with t = 1.0 * parent.t and the right child with t = 0.0
        tree.nodes[leftIndex].t = 1.0 * t;
        tree.nodes[rightIndex].t = 0.0;
      } else if (feature >= HIGH_FEATURE_LEVEL){
        // create the left child with 0 and the right child with t = 1.0 * parent.t
        tree.nodes[leftIndex].t = 0.0;
        tree.nodes[rightIndex].t = 1.0 * t;
      } else {
        // calculate t with inverse lerp and create the left and right children
        float leftT = InverseLerp(LOW_FEATURE_LEVEL, HIGH_FEATURE_LEVEL, feature);
        tree.nodes[leftIndex].t = leftT * t;
        tree.nodes[rightIndex].t = (1.0 - leftT) * t;
      }
    }
  }

  return tree;
}

BiomeInterpolation GetBiomeInterpolationForTree(BiomeTree tree){ 
  BiomeInterpolation interp;

  for (uint i = 0; i < biomeCount; i++){
    BiomeNode n = tree.nodes[i];
    interp.values[i] = n.t;
  }

  return interp; 
}

/**
  * Returns the list of interpolation values for a Biome for an array of features
  * this will probably be called for each voxel vertex and then the result will be
  * a list of 16 float values which I can use to derive a biome as:
  * biome = sum(values[i] * i) for i in 0 to 15
  * if I can render the result of this into a texture I can use it
  * to determine biome everywhere else in the code
  * @param features the array of features for the voxel
  * @return a list of 16 float values to be used as interpolation values
  */
BiomeInterpolation GetBiomeInterp(float features[featureCount]){

  BiomeTree tree = InterpolateBiomes(features);
  return GetBiomeInterpolationForTree(tree);
}

// ====================== Density ====================== //


/**
 * Generates an octave of noise with
 * the given parameters for frequency and amplitude
 * the value is capped at `cap`
*/
float GetOctave(float3 position, float frequency, float amplitude, float cap)
{
	float octave = _NoiseMapVol1.SampleLevel(TrilinearRepeat, position.xz * frequency, 0).x * amplitude;
	if(octave > cap) octave = cap;
	return octave;
}

/**
 * Generates a 2D octave of noise with
 * the given parameters for frequency and amplitude
 * the value is capped at `cap`
*/
float Get2DOctave(float3 position, float frequency, float amplitude, float cap)
{
  float level1 = _NoiseMapVol1.SampleLevel(TrilinearRepeat, position.xz * frequency, 0).x;
  float level2 = _NoiseMapVol2.SampleLevel(TrilinearRepeat, position.xy * frequency, 0).x;
  float octave = level1 * level2;

	octave = pow(octave, 1.0/3.0) * amplitude;
	if(octave > cap) octave = cap;
	return octave;
}

/**
 * Generates a 3D octave of noise with
 * the given parameters for frequency and amplitude
 * the value is capped at `cap`
*/
float Get3DOctave(float3 position, float frequency, float amplitude, float cap)
{
  float bias = 12.0;
  float level1 = _NoiseMapVol1.SampleLevel(TrilinearRepeat, position.xz * frequency, 0).x;
  float level2 = _NoiseMapVol2.SampleLevel(TrilinearRepeat, position.yz * frequency, 0).x;
  float level3 = _NoiseMapVol3.SampleLevel(TrilinearRepeat, position.xy * frequency, 0).x;
  float octave = pow(level1, bias) * level2 * level3;

	octave = pow(octave, 1.0/(bias + 2.0)) * amplitude;
	if(octave > cap) octave = cap;
	return octave;
}

/**
 * Gets the warp value for the 2D position
*/
float3 GetWarp(float2 position, float frequency, float amplitude)
{
	return _NoiseMapVol2.SampleLevel(TrilinearRepeat, position * frequency, 0).xyz * amplitude;
}

/**
  * Sample the biome map at the given position
  */
BiomeInterpolation GetBiome(float3 position)
{
  float biomeStep = 0.00001;
  float features[4];
  features[0] = _ErosionMap.SampleLevel(TrilinearRepeat, position.xz * biomeStep, 0).r;
  features[1] = _TemperatureMap.SampleLevel(TrilinearRepeat, position.xz * biomeStep, 0).r;
  features[2] = _PrecipitationMap.SampleLevel(TrilinearRepeat, position.xz * biomeStep, 0).r;
  features[3] = _SeismicMap.SampleLevel(TrilinearRepeat, position.xz * biomeStep, 0).r;
  return GetBiomeInterp(features);
}

float HardFloor(float3 worldSpace){
  float hardFloor = _Elevation;
  return saturate((hardFloor - worldSpace.y) * 3.0) * _ChunkSize;
}

// ====================== Biome Functions ====================== //

float RockyMeadowsDensity(float3 worldSpace, float3 chunkSpace){
	float3 warp = float3(0, 0, 0);
	float density = -chunkSpace.y - 24.0;
 
	// Warp the position
	warp += GetWarp(worldSpace.xy, 0.00025, 128.0);
	warp += GetWarp(worldSpace.zy, 0.00025, 128.0);
	float3 wrappedWorldSpace = worldSpace + warp;
	
	// Upper octaves
	density += GetOctave(wrappedWorldSpace, .001, 42.0, 38.0);
	density += GetOctave(wrappedWorldSpace, .003, 22.0, 16.0);
	density += GetOctave(wrappedWorldSpace, .005, 15.0, 8.0);

	// Lower octaves
	density += GetOctave(worldSpace, .008, 8.0, 4.0);
	density += GetOctave(worldSpace, .01, 6.0, 2.0);
	density += GetOctave(worldSpace, .05, 0.8, 0.8);
	density += GetOctave(worldSpace, .1, 0.4, 0.4);
	density += GetOctave(worldSpace, .5, 0.2, 0.2);
	density += GetOctave(worldSpace, .8, 0.1, 0.1);

	density += HardFloor(worldSpace);

	return density;
}

float DeepSeaDensity(float3 worldSpace, float3 chunkSpace){
	float density = -chunkSpace.y;

	// Upper octaves
	density += GetOctave(worldSpace, .001, 8.0, 8.0);
	density += GetOctave(worldSpace, .003, 4.0, 4.0);
	density += GetOctave(worldSpace, .005, 1.0, 1.0);

	// Lower octaves
	density += GetOctave(worldSpace, .008, 1.0, 1.0);
	density += GetOctave(worldSpace, .01, 0.8, 0.8);
	density += GetOctave(worldSpace, .05, 0.6, 0.6);
	density += GetOctave(worldSpace, .1, 0.4, 0.4);
	density += GetOctave(worldSpace, .5, 0.2, 0.2);
	density += GetOctave(worldSpace, .8, 0.1, 0.1);

	density += HardFloor(worldSpace);

  return density;
}

float CavernsDensity(float3 worldSpace, float3 chunkSpace){
	float density = chunkSpace.y - 50.0;

	// Upper octaves
	density += Get3DOctave(worldSpace, .001, 42.0, 38.0);
	density += Get3DOctave(worldSpace, .003, 22.0, 16.0);
	// density += Get3DOctave(worldSpace, .005, 15.0, 8.0);

	// Lower octaves
	density += Get3DOctave(worldSpace, .008, 8.0, 4.0);
	density += Get3DOctave(worldSpace, .01, 6.0, 2.0); 
	density += Get3DOctave(worldSpace, .05, 0.8, 0.8);
	density += Get3DOctave(worldSpace, .1, 0.4, 0.4);
	density += Get3DOctave(worldSpace, .5, 0.2, 0.2);
	density += Get3DOctave(worldSpace, .8, 0.1, 0.1);

	density += HardFloor(worldSpace);

  return density;
}

float SerenityFieldsDensity(float3 worldSpace, float3 chunkSpace){
	float density = -chunkSpace.y;

	// Upper octaves
	density += Get3DOctave(worldSpace, .001, 42.0, 38.0);

	density += HardFloor(worldSpace);

  return density;
}

float CanyonsDensity(float3 worldSpace, float3 chunkSpace){
	float density = -chunkSpace.y;

	// Lower octaves
  float level1 = pow(GetOctave(worldSpace, .0025, 5.3, 4.0), 3);
  float level2 = pow(GetOctave(worldSpace, .0025, 5.5, 3.5), 3);
  float level3 = pow(GetOctave(worldSpace, .0025, 5.7, 2.6), 3);
  float elevation = max(level1, level2);
  elevation = max(elevation, level3);
	density += elevation;

	density += HardFloor(worldSpace);

  return density;
}

float SteamingValleyDensity(float3 worldSpace, float3 chunkSpace){
	float density = -chunkSpace.y;

	density += pow(Get3DOctave(worldSpace, .004, 6.0, 4.0), 3);

	density += HardFloor(worldSpace);

  return density;
}

float WastelandDensity(float3 worldSpace, float3 chunkSpace){
	float density = -chunkSpace.y;

	// Upper octaves
	density += Get3DOctave(worldSpace, .001, 42.0, 38.0);

	// Lower octaves
	density += Get3DOctave(worldSpace, .008, 8.0, 4.0);
	density += Get3DOctave(worldSpace, .01, 6.0, 2.0); 
	density += pow(Get3DOctave(worldSpace, .05, 1.0, 1.0), 2);

	density += HardFloor(worldSpace);

  return density;
}

float BloomingHillsDensity(float3 worldSpace, float3 chunkSpace){
	float density = -chunkSpace.y;

	// Upper octaves
  density += GetOctave(worldSpace, .005, 42.0, 42.0);

	// Lower octaves

	density += HardFloor(worldSpace);

  return density;
}

float UnderwaterTundraDensity(float3 worldSpace, float3 chunkSpace){
	float3 warp = float3(0, 0, 0);
	float density = -chunkSpace.y - 24.0;
 
	// Warp the position
	warp += GetWarp(worldSpace.xy, 0.00025, 128.0);
	warp += GetWarp(worldSpace.zy, 0.00025, 128.0);
	float3 wrappedWorldSpace = worldSpace + warp;

	float level1 = pow(Get3DOctave(wrappedWorldSpace, .0006, 13.0, 8.0), 2);
  float level2 = pow(Get3DOctave(wrappedWorldSpace, .002, 1.5, 1.5), 4);

  density += max(level1, level2);

	density += HardFloor(worldSpace);

  return density;
}

float TropicalIslandsDensity(float3 worldSpace, float3 chunkSpace){
	float density = -chunkSpace.y;

	// Lower octaves
  float level1 = pow(GetOctave(worldSpace, .0025, 5.3, 4.0), 3);
  float level2 = pow(GetOctave(worldSpace, .0025, 5.5, 3.5), 3);
  float level3 = pow(Get3DOctave(worldSpace, .0025, 5.7, 2.6), 3);
  float elevation = max(level1, level2);
  elevation = max(elevation, level3);
	density += elevation;

	density += HardFloor(worldSpace);

  return density;
}

float DeadlandsDensity(float3 worldSpace, float3 chunkSpace){
	float density = -chunkSpace.y;

	density += Get3DOctave(worldSpace, .008, 8.0, 4.0);
	density += Get3DOctave(worldSpace, .01, 6.0, 2.0); 
	density += Get3DOctave(worldSpace, .05, 0.8, 0.8);
	density += Get3DOctave(worldSpace, .1, 0.4, 0.4);
	density += Get3DOctave(worldSpace, .5, 0.2, 0.2);
	density += Get3DOctave(worldSpace, .8, 0.1, 0.1);

	density += HardFloor(worldSpace);

  return density;
}

float StoneValleyDensity(float3 worldSpace, float3 chunkSpace){
	float density = -1.0 * (_ChunkSize + 18.0);

	// Upper octaves
	density += Get3DOctave(worldSpace, .001, 42.0, 38.0);
	density += Get3DOctave(worldSpace, .003, 22.0, 16.0);
	density += Get3DOctave(worldSpace, .005, 15.0, 8.0);

	// Lower octaves
	density += Get3DOctave(worldSpace, .008, 8.0, 4.0);
	density += Get3DOctave(worldSpace, .01, 6.0, 2.0); 
	density += Get3DOctave(worldSpace, .05, 0.8, 0.8);
	density += Get3DOctave(worldSpace, .1, 0.4, 0.4);
	density += Get3DOctave(worldSpace, .5, 0.2, 0.2);
	density += Get3DOctave(worldSpace, .8, 0.1, 0.1);

	density += HardFloor(worldSpace);

  return density;
}

float AcidPlateauDensity(float3 worldSpace, float3 chunkSpace){
	float density = -1.0 * (_ChunkSize + 18.0);

	// Upper octaves
	density += Get3DOctave(worldSpace, .001, 42.0, 38.0);
	density += Get3DOctave(worldSpace, .003, 22.0, 16.0);
	density += Get3DOctave(worldSpace, .005, 15.0, 8.0);

	// Lower octaves
	density += Get3DOctave(worldSpace, .008, 8.0, 4.0);
	density += Get3DOctave(worldSpace, .01, 6.0, 2.0); 
	density += Get3DOctave(worldSpace, .05, 0.8, 0.8);
	density += Get3DOctave(worldSpace, .1, 0.4, 0.4);
	density += Get3DOctave(worldSpace, .5, 0.2, 0.2);
	density += Get3DOctave(worldSpace, .8, 0.1, 0.1);

	density += HardFloor(worldSpace);

  return density;
}

float DarkDeepsDensity(float3 worldSpace, float3 chunkSpace){
	float density = -chunkSpace.y;

	density += GetOctave(worldSpace, .008, 8.0, 4.0);
	density += GetOctave(worldSpace, .01, 6.0, 2.0); 
	density += GetOctave(worldSpace, .05, 0.8, 0.8);
	density += GetOctave(worldSpace, .1, 0.4, 0.4);
	density += GetOctave(worldSpace, .5, 0.2, 0.2);
	density += GetOctave(worldSpace, .8, 0.1, 0.1);

	density += HardFloor(worldSpace);

  return density;
}

float NowhereDensity(float3 worldSpace, float3 chunkSpace){
	float density = -chunkSpace.y;

  return density;
}

float ScarletVeilDensity(float3 worldSpace, float3 chunkSpace){
	float density = 60 - chunkSpace.y;

	// Upper octaves
	density -= Get3DOctave(worldSpace, .001, 42.0, 38.0);
	density -= Get3DOctave(worldSpace, .003, 22.0, 16.0);
	density -= Get3DOctave(worldSpace, .005, 15.0, 8.0);

	// Lower octaves
	density -= Get3DOctave(worldSpace, .008, 8.0, 4.0);
	density -= Get3DOctave(worldSpace, .01, 6.0, 2.0); 
	density -= Get3DOctave(worldSpace, .05, 0.8, 0.8);
	density -= Get3DOctave(worldSpace, .1, 0.4, 0.4);
	density -= Get3DOctave(worldSpace, .5, 0.2, 0.2);
	density -= Get3DOctave(worldSpace, .8, 0.1, 0.1);

	density += HardFloor(worldSpace);

  return density;
}

/**
 * Returns the density value of
 * the vertex at (x, y, z) on the chunk
 * at position _ChunkPosition
*/
float CalculateDensity(uint3 id)
{
	if(id.y >= _ChunkSize - 1) return _IsoLevel - 1; 

	float3 chunkSpace = float3(id);
	float3 worldSpace = _ChunkPosition + (chunkSpace * _Scale);

  BiomeInterpolation interp = GetBiome(worldSpace);

  float density = 0.0;

  density += (RockyMeadowsDensity(worldSpace, chunkSpace) * interp.values[0]);
  density += (DeepSeaDensity(worldSpace, chunkSpace) * interp.values[1]);
  density += (CavernsDensity(worldSpace, chunkSpace) * interp.values[2]);
  density += (SerenityFieldsDensity(worldSpace, chunkSpace) * interp.values[3]);
  density += (CanyonsDensity(worldSpace, chunkSpace) * interp.values[4]);
  density += (SteamingValleyDensity(worldSpace, chunkSpace) * interp.values[5]);
  density += (WastelandDensity(worldSpace, chunkSpace) * interp.values[6]);
  density += (BloomingHillsDensity(worldSpace, chunkSpace) * interp.values[7]);
  density += (UnderwaterTundraDensity(worldSpace, chunkSpace) * interp.values[8]);
  density += (TropicalIslandsDensity(worldSpace, chunkSpace) * interp.values[9]);
  density += (DeadlandsDensity(worldSpace, chunkSpace) * interp.values[10]);
  density += (StoneValleyDensity(worldSpace, chunkSpace) * interp.values[11]);
  density += (AcidPlateauDensity(worldSpace, chunkSpace) * interp.values[12]);
  density += (DarkDeepsDensity(worldSpace, chunkSpace) * interp.values[13]);
  density += (NowhereDensity(worldSpace, chunkSpace) * interp.values[14]);
  density += (RockyMeadowsDensity(worldSpace, chunkSpace) * interp.values[15]);

  // // density = -chunkSpace.y;
  // for (uint i = 0; i < 16; i++){
  //   density += 2 * interp.values[i]; 
  // }

  return density;
}

// ====================== Marching Cubes ====================== //

/**
 * Returns the index of voxel that corresponds
 * to the cube at "cubeOrigin" on the edge table
*/
int GetCubeIndex(uint3 cubeOrigin)
{
	int cubeIndex = 0;
	for (int i = 0; i < 8; i++)
	{
		uint3 vertex = cubeOrigin + GetVertexOffset(i);
		uint idx = PositionToBufferIndex(vertex);
		float density = _ChunkVertices[idx];
		if (density < _IsoLevel) cubeIndex |= (1 << i);
	}
	return cubeIndex;
}

/**
 * Linear interpolation vertices
*/
float3 Interpolate(float3 a, float3 b, float densityA, float densityB) {
	float3 t = InverseLerp(densityA, densityB, _IsoLevel);

	return LerpPosition(a, b, t);
}

/**
 * Generates the vertices for the of
 * the voxel "cubeIndex" at position "_ChunkPosition + id"
*/
void CalculateVoxelGeneratedVertices(uint3 id, int cubeIndex, inout float3 generatedVertices[12]){
	int voxelIndex = edgeTable[cubeIndex];

	for (int i = 0; i < 12; i++)
	{
		uint edgeCode = 1 << i;

		// If true, there is a vertex to be
		// generated on edge i
		if((voxelIndex & edgeCode) > 0) {
			uint2 edgeVertices = GetVerticesForEdge(i);
			uint3 a = id + GetVertexOffset(edgeVertices.x);
			uint3 b = id + GetVertexOffset(edgeVertices.y);

			float3 aWorldPos = a;
			float3 bWorldPos = b;

			float densityA = _ChunkVertices[PositionToBufferIndex(a)];
			float densityB = _ChunkVertices[PositionToBufferIndex(b)];
			generatedVertices[i] = Interpolate(aWorldPos, bWorldPos, densityA, densityB);
		}
	}
}

/**
 * Generates the grass for the given triangle
*/
void GenerateTriangleVegetation(Triangle tri){
	float3 ctr = GetCentroid(tri);
	float vegetationValue = _NoiseMapVol3.SampleLevel(TrilinearRepeat, ctr.xz * .001, 0).r;

  if(vegetationValue < (1.0 - vegetationDensity)) return;

	float3 normal = GetNormal(tri);
	float3 up = float3(0, 1, 0);
	float dotProd = dot(normal, up);
  _ChunkVegetation.Append(float4(ctr, dotProd));
}

/**
 * Generates the triangles for the voxel
 * "cubeIndex" at position "_ChunkPosition + id"
*/
void GenerateVoxelTriangles(int cubeIndex, float3 generatedVertices[12], bool hasVegetation){
	int triangles[16] = triTable[cubeIndex];

	for(uint i = 0; triangles[i] != -1; i += 3){
		Triangle tri = CreateTriangle(
			generatedVertices[triangles[i]],
			generatedVertices[triangles[i + 1]],
			generatedVertices[triangles[i + 2]]
		);
		_ChunkTriangles.Append(tri);

		if(hasVegetation && i == 0){
			GenerateTriangleVegetation(tri); 
		}
	}
}

// ====================== Kernels ====================== //

[numthreads(threads, threads, threads)]
void DistributeDensity (uint3 id : SV_DispatchThreadID)
{
	if(id.x >= _ChunkSize || id.y >= _ChunkSize || id.z >= _ChunkSize){
		return;
	}

	uint idx = PositionToBufferIndex(id);
	_ChunkVertices[idx] = CalculateDensity(id);
}

[numthreads(threads, threads, threads)]
void GenerateMesh (uint3 id : SV_DispatchThreadID)
{
	uint cubesPerAxis = _ChunkSize - 1;
	if(id.x >= cubesPerAxis || id.y >= cubesPerAxis || id.z >= cubesPerAxis){
		return;
	}

	uint bufferIndex = PositionToBufferIndex(id);
	int cubeIndex = GetCubeIndex(id);
	if (cubeIndex == 0 || cubeIndex == 255) return;

	float3 generatedVertices[12];
	bool hasVegetation = bufferIndex % vegetationSparsity == 0;
	CalculateVoxelGeneratedVertices(id, cubeIndex, generatedVertices);
	GenerateVoxelTriangles(cubeIndex, generatedVertices, hasVegetation);
}

[numthreads(threads, threads, threads)]
void Terraform (uint3 id : SV_DispatchThreadID)
{
	if(id.x >= _ChunkSize || id.y >= _ChunkSize || id.z >= _ChunkSize){
		return;
	}

	if(id.y == _ChunkSize -1 || id.y == 0) return;

	uint idx = PositionToBufferIndex(id);
	float distance = length(_TerraformPosition - id);
	float density = _ChunkVertices[idx];
	if(distance < _TerraformRadius){
		float falloff = saturate(1.0 - (distance / _TerraformRadius));
		_ChunkVertices[idx] = density + (_TerraformStrength * falloff * _TerraformDirection);
	}
}
