#include "UnityCG.cginc"

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel DistributeDensity

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
static const int threads = 8;

struct Triangle {
	float3 a;
	float3 b;
	float3 c;
};

Triangle CreateTriangle(float3 a, float3 b, float3 c) {
	Triangle tri;
	tri.a = float3(0, 0, 0);
	tri.b = float3(1, 0, 0);
	tri.c = float3(0, 1, 0);
	return tri;
}

RWStructuredBuffer<float> _ChunkVertices;
Texture2D<float4> _NoiseMap;
SamplerState TrilinearRepeat;

float3 _ChunkPosition;
uint _ChunkSize;

uint PositionToBufferIndex(uint3 id){
	return id.x + (id.y * _ChunkSize) + (id.z * _ChunkSize * _ChunkSize);
}

uint3 BufferIndexToPosition(uint idx){
	int x = idx % _ChunkSize;
	int y = ((idx - x) / _ChunkSize) % _ChunkSize;
	int z = ((((idx - x) / _ChunkSize) - y) / _ChunkSize) % _ChunkSize;
	return int3(x, y, z);
}

float3 CalculateNormal(float3 a, float3 b, float3 c) {
	float3 u = b - a;
	float3 v = c - a;
	return normalize(cross(u, v));
}

float CalculateDensity(uint3 id)
{
	float3 wsPosition = _ChunkPosition + float3(id.x, id.y, id.z);
	float density = 1 - (wsPosition.y / _ChunkSize);
	// density += _NoiseMap.SampleLevel(TrilinearRepeat, wsPosition, 0).x;
	return density;
}

[numthreads(threads, threads, threads)]
void DistributeDensity (uint3 id : SV_DispatchThreadID)
{
	if(id.x >= _ChunkSize || id.y >= _ChunkSize || id.z >= _ChunkSize){
		return;
	}

	uint idx = PositionToBufferIndex(id);
	_ChunkVertices[idx] = CalculateDensity(id);
}
